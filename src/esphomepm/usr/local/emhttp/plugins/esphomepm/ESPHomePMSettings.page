Menu="Utilities"
Icon="esphomepm.png"
Title="ESPHome Power Monitor"
---
<?php
$esphomepm_cfg = parse_plugin_cfg("esphomepm",true);
$esphomepm_device_ip = isset($esphomepm_cfg['DEVICE_IP']) ? $esphomepm_cfg['DEVICE_IP'] : "";
$esphomepm_device_name = isset($esphomepm_cfg['DEVICE_NAME']) ? $esphomepm_cfg['DEVICE_NAME'] : "Unraid Server PM";
$esphomepm_uirefresh = isset($esphomepm_cfg['UIREFRESH']) ? $esphomepm_cfg['UIREFRESH'] : "1000";
$esphomepm_costs_price = isset($esphomepm_cfg['COSTS_PRICE']) ? $esphomepm_cfg['COSTS_PRICE'] : "0.27";
$esphomepm_costs_unit = isset($esphomepm_cfg['COSTS_UNIT']) ? $esphomepm_cfg['COSTS_UNIT'] : "GBP";
?>

<form markdown="1" method="POST" action="/update.php" target="progressFrame">
<input type="hidden" name="#file" value="esphomepm/esphomepm.cfg" />

Device Name:
: <input id="DEVICE_NAME" type="text" class="stopped" name="DEVICE_NAME" maxlength="50" value="<?=$esphomepm_device_name;?>" title="" placeholder="ESPHome Device Name" >  

Device IP:
: <input id="DEVICE_IP" type="text" class="stopped" name="DEVICE_IP" maxlength="15" value="<?=$esphomepm_device_ip;?>" title="" placeholder="192.168.1.x" >  


UI Refresh rate (Milliseconds):
: <input type="text" id="UIREFRESH" name="UIREFRESH" class="narrow" maxlength="50" value="<?=$esphomepm_uirefresh;?>" placeholder="1000">

Price per kWh for cost calculation:
: <input id="COSTS_PRICE" type="text" class="stopped" name="COSTS_PRICE" maxlength="10" value="<?=$esphomepm_costs_price;?>" title="" placeholder="0.00" >  

Unit for cost calculation:
: <input id="COSTS_UNIT" type="text" class="stopped" name="COSTS_UNIT" maxlength="10" value="<?=$esphomepm_costs_unit;?>" title="" placeholder="" >  

 <input id="DEFAULT" class="stopped" type="button" value="Default" onClick="resetDATA(this.form)">
: <input id="btnApply" type="submit" value="Apply"><input type="button" value="Done" onClick="done()">
</form>

<style>
    .value-display {
        transition: all 0.3s ease;
    }
    .value-updated {
        filter: brightness(1.5); /* Simple brightness increase that works with any theme */
    }
</style>

<div id="deviceStatus" style="margin-top: 20px; padding: 10px; border: 1px solid #ccc; display: none;">
    <h3>Power Monitoring</h3>
    <div id="sensorValues">
        <h4>Current Readings</h4>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <div>
                <p>Current Power: <span id="currentPower" class="value-display">--</span> W</p>
                <p>Daily Energy: <span id="dailyEnergy" class="value-display">--</span> kWh</p>
                <p>Voltage: <span id="voltage" class="value-display">--</span> V</p>
                <p>Current: <span id="current" class="value-display">--</span> A</p>
            </div>
            <div>
                <p>Daily Cost: <span id="dailyCost" class="value-display">--</span> <span id="costUnit">--</span></p>
                <p>Monthly Cost (Est.): <span id="monthlyCost" class="value-display">--</span> <span id="costUnitMonthly">--</span></p>
                <p>Monitoring Since: <span id="monitoringSince">--</span></p>
            </div>
        </div>
        
        <h4 style="margin-top: 20px;">Power Usage Graph</h4>
        <div id="powerGraphContainer" style="margin-top: 10px; height: 250px;">
            <canvas id="powerGraph"></canvas>
        </div>
        
        <h4 style="margin-top: 20px;">Monthly Costs</h4>
        <div id="monthlyCostsContainer" style="margin-top: 10px;">
            <table id="monthlyCostsTable" class="tablesorter" style="width: 100%;">
                <thead>
                    <tr>
                        <th>Month</th>
                        <th>Energy (kWh)</th>
                        <th>Cost</th>
                    </tr>
                </thead>
                <tbody id="monthlyCostsBody">
                    <!-- Monthly cost data will be inserted here -->
                </tbody>
                <tfoot>
                    <tr>
                        <td colspan="2"><strong>Total since <span id="totalSinceDate">--</span>:</strong></td>
                        <td><strong><span id="totalCost">--</span> <span id="totalCostUnit">--</span></strong></td>
                    </tr>
                </tfoot>
            </table>
        </div>
    </div>
</div>

<!-- Include Chart.js from CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>

<script type="text/javascript">
function resetDATA(form) {
    // Reset form values to defaults
    form.DEVICE_IP.value = "";
    form.DEVICE_NAME.value = "";
    form.UIREFRESH.value = 1000;
    form.COSTS_PRICE.value = 0.27;
    form.COSTS_UNIT.value = "GBP";
    
    // Submit the form to save the default values
    form.submit();
}

function done() {
    window.location.href = '/Main';
}

// Function to load monthly cost data from server
async function loadMonthlyCostData() {
    try {
        const timestamp = new Date().getTime();
        const response = await fetch(`/plugins/esphomepm/monthly_data.php?t=${timestamp}`);
        if (!response.ok) {
            throw new Error(`Failed to load monthly data: ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.error('Error loading monthly data:', error);
        // Return empty data structure if loading fails
        const now = new Date();
        const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        const startDate = now.toISOString().split('T')[0];
        
        const initialData = {
            startDate: startDate,
            months: {}
        };
        initialData.months[currentMonth] = { energy: 0, cost: 0 };
        
        return initialData;
    }
}

// Function to update monthly cost data with today's reading
async function updateMonthlyCostData(dailyEnergy, costPrice) {
    try {
        console.log(`Updating monthly data with dailyEnergy=${dailyEnergy}, costPrice=${costPrice}`);
        
        // Validate inputs to prevent sending invalid data
        if (isNaN(dailyEnergy) || isNaN(costPrice) || dailyEnergy < 0 || costPrice < 0) {
            console.error('Invalid input values for monthly data update');
            return await loadMonthlyCostData();
        }
        
        // Prepare the data with proper formatting
        const updateData = {
            dailyEnergy: parseFloat(dailyEnergy),
            costPrice: parseFloat(costPrice)
        };
        
        // Log the data being sent
        console.log('Sending data to server:', updateData);
        
        // Send the update to the server
        const response = await fetch('/plugins/esphomepm/monthly_data.php', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updateData)
        });
        
        // Check for HTTP errors
        if (!response.ok) {
            throw new Error(`Failed to update monthly data: ${response.status}`);
        }
        
        // Get the response text first to check if it's valid JSON
        const responseText = await response.text();
        console.log('Server response:', responseText);
        
        // Check if the response is empty
        if (!responseText || responseText.trim() === '') {
            console.error('Empty response from server');
            
            // Try a simple ping to the server to check if it's responsive
            try {
                const pingResponse = await fetch('/plugins/esphomepm/monthly_data.php?ping=true');
                if (pingResponse.ok) {
                    console.log('Server is responsive, but returned empty response for update');
                } else {
                    console.error('Server is not responsive:', pingResponse.status);
                }
            } catch (pingError) {
                console.error('Error pinging server:', pingError);
            }
            
            // Wait a moment before retrying
            await new Promise(resolve => setTimeout(resolve, 1000));
            return await loadMonthlyCostData();
        }
        
        // Try to parse the JSON response
        let result;
        try {
            result = JSON.parse(responseText);
        } catch (parseError) {
            console.error('Failed to parse JSON response:', parseError, 'Response was:', responseText);
            return await loadMonthlyCostData();
        }
        
        // Check for error in the result
        if (result.error) {
            console.error('Server returned error:', result.error);
            return await loadMonthlyCostData();
        }
        
        // Return the data
        return result.data;
    } catch (error) {
        console.error('Error updating monthly data:', error);
        // If update fails, just return the current data
        return await loadMonthlyCostData();
    }
}

// Function to display monthly cost data in the table
function displayMonthlyCostData(data, costUnit) {
    const tableBody = document.getElementById('monthlyCostsBody');
    tableBody.innerHTML = '';
    
    // Sort months in descending order
    const sortedMonths = Object.keys(data.months).sort().reverse();
    
    let totalCost = 0;
    let totalEnergy = 0;
    
    sortedMonths.forEach(month => {
        const monthData = data.months[month];
        const row = document.createElement('tr');
        
        // Format month for display (YYYY-MM to Month YYYY)
        const [year, monthNum] = month.split('-');
        const monthDate = new Date(year, parseInt(monthNum) - 1, 1);
        const monthName = monthDate.toLocaleString('default', { month: 'long' });
        const displayMonth = `${monthName} ${year}`;
        
        row.innerHTML = `
            <td>${displayMonth}</td>
            <td>${monthData.energy.toFixed(2)}</td>
            <td>${monthData.cost.toFixed(2)} ${costUnit}</td>
        `;
        
        tableBody.appendChild(row);
        
        totalCost += monthData.cost;
        totalEnergy += monthData.energy;
    });
    
    // Update the total
    document.getElementById('totalCost').textContent = totalCost.toFixed(2);
    document.getElementById('totalCostUnit').textContent = costUnit;
    
    // Format the start date
    const startDate = new Date(data.startDate);
    const startMonth = startDate.toLocaleString('default', { month: 'long' });
    document.getElementById('totalSinceDate').textContent = `${startMonth} ${startDate.getFullYear()}`;
    document.getElementById('monitoringSince').textContent = startDate.toLocaleDateString();
    
    return { totalCost, totalEnergy };
}

// Function to update power monitoring data
async function updateDeviceStatus() {
    const deviceIP = document.getElementById('DEVICE_IP').value;
    if (!deviceIP) {
        document.getElementById('deviceStatus').style.display = 'none';
        return;
    }
    
    document.getElementById('deviceStatus').style.display = 'block';
    
    try {
        // Add timestamp to prevent caching
        const timestamp = new Date().getTime();
        
        // Use our PHP proxy to get the data
        const response = await fetch(`/plugins/esphomepm/status.php?t=${timestamp}`);
        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('Power data received:', data);
        
        // Check if there's an error message
        if (data.error) {
            console.error('Error in data:', data.error);
            return;
        }
        
        // Get cost price and unit
        const costPrice = parseFloat(data.Costs_Price) || 0.27;
        const costUnit = data.Costs_Unit || 'GBP';
        
        // Function to update a value with smooth transition
        function updateValueWithTransition(elementId, newValue, decimals = 2) {
            const element = document.getElementById(elementId);
            const formattedValue = Number(newValue).toFixed(decimals);
            
            // Only apply transition if value has changed
            if (element.textContent !== formattedValue) {
                element.textContent = formattedValue;
                element.classList.add('value-updated');
                
                // Remove the highlight class after transition completes
                setTimeout(() => {
                    element.classList.remove('value-updated');
                }, 500);
            }
        }
        
        // Batch all UI updates together to ensure they happen at the same time
        // This ensures both numeric values and graph update at exactly the same rate
        requestAnimationFrame(() => {
            // Update all values with smooth transitions
            updateValueWithTransition('currentPower', data.Power);
            updateValueWithTransition('dailyEnergy', data.Total);
            updateValueWithTransition('voltage', data.Voltage);
            updateValueWithTransition('current', data.Current);
            
            // Update the power graph with the new power value
            updatePowerGraph(data.Power);
        });
        
        // Calculate and display costs
        const dailyEnergy = Number(data.Total);
        const dailyCost = dailyEnergy * costPrice;
        const monthlyCost = dailyCost * 30; // Estimate based on 30 days
        
        updateValueWithTransition('dailyCost', dailyCost);
        updateValueWithTransition('monthlyCost', monthlyCost);
        
        // Update units
        document.getElementById('costUnit').textContent = costUnit;
        document.getElementById('costUnitMonthly').textContent = costUnit;
        document.getElementById('totalCostUnit').textContent = costUnit;
        
        // Update monthly data on the server
        const monthlyData = await updateMonthlyCostData(dailyEnergy, costPrice);
        displayMonthlyCostData(monthlyData, costUnit);
    } catch (error) {
        console.error('Error fetching power data:', error);
    }
}

// Global variables
let refreshInterval;
let powerChart;
let powerData = {
    labels: [],
    datasets: [{
        label: 'Power (W)',
        data: [],
        borderColor: '#E68A00',       // Unraid orange color
        backgroundColor: 'rgba(230, 138, 0, 0.1)', // Transparent orange
        borderWidth: 3,              // Slightly thicker line
        fill: true,                  // Fill area under the line
        tension: 0.6,                // Higher tension for smoother curve
        pointRadius: 0,              // Remove the dots
        pointHoverRadius: 4          // Show points only on hover
    }]
};

// Maximum number of data points to show on the graph
const MAX_DATA_POINTS = 60; // 2 minutes at 2-second intervals

// Function to set up the refresh interval
function setupRefreshInterval() {
    // Clear any existing interval
    if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
    }
    
    // Get the refresh rate from the input field
    let refreshRate = parseInt(document.getElementById('UIREFRESH').value) || 1000;
    
    // Enforce a minimum refresh rate of 2000ms to prevent overloading the ESPHome device
    const MIN_REFRESH_RATE = 2000; // 2 seconds minimum
    if (refreshRate < MIN_REFRESH_RATE) {
        console.warn(`Refresh rate ${refreshRate}ms is too low and may overload the ESPHome device. Using ${MIN_REFRESH_RATE}ms instead.`);
        refreshRate = MIN_REFRESH_RATE;
        // Update the input field to show the actual value being used
        document.getElementById('UIREFRESH').value = MIN_REFRESH_RATE;
    }
    
    console.log('Setting refresh rate to', refreshRate, 'ms');
    
    // Set up new interval if refresh rate is positive
    if (refreshRate > 0) {
        // Immediate update
        updateDeviceStatus();
        
        // Set interval for future updates
        refreshInterval = setInterval(updateDeviceStatus, refreshRate);
    }
}

// Function to apply settings without page reload
function applySettings(form) {
    // Don't prevent default form submission - let it work normally
    // The form is already set to submit to /update.php with target="progressFrame"
    return true;
};

// This is a backup function that can be used if the normal form submission doesn't work
function applySettingsAjax(form) {
    // Get the form data
    const formData = new FormData(form);
    
    // Send the form data to the server
    fetch('/update.php', {
        method: 'POST',
        body: formData
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Failed to save settings');
        }
        return response.text();
    })
    .then(() => {
        // Update the refresh interval immediately
        setupRefreshInterval();
        
        // Show a success message
        alert('Settings applied successfully!');
    })
    .catch(error => {
        console.error('Error applying settings:', error);
        alert('Failed to apply settings: ' + error.message);
    });
    
    return false;
}

// Function to initialize the power usage graph
function initializePowerGraph() {
    const ctx = document.getElementById('powerGraph').getContext('2d');
    
    // Destroy existing chart if it exists
    if (powerChart) {
        powerChart.destroy();
    }
    
    // Create gradient fill for the area under the line (like Unraid dashboard)
    const gradient = ctx.createLinearGradient(0, 0, 0, 300);
    gradient.addColorStop(0, 'rgba(230, 138, 0, 0.4)');  // More opaque at top
    gradient.addColorStop(0.5, 'rgba(230, 138, 0, 0.1)'); // Semi-transparent in middle
    gradient.addColorStop(1, 'rgba(230, 138, 0, 0)');    // Transparent at bottom
    
    // Update the dataset background
    powerData.datasets[0].backgroundColor = gradient;
    
    // Create the chart with Unraid styling
    powerChart = new Chart(ctx, {
        type: 'line',
        data: powerData,
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
                duration: 1000, // Longer animation for smoother flow
                easing: 'linear' // Linear easing for constant flow speed
            },
            elements: {
                line: {
                    tension: 0.4 // Smoother curve
                }
            },
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: false
            },
            scales: {
                x: {
                    display: true,
                    grid: {
                        color: 'rgba(255, 255, 255, 0.05)', // Very subtle grid lines
                        drawBorder: false
                    },
                    title: {
                        display: false // Hide title for cleaner look
                    },
                    ticks: {
                        maxTicksLimit: 5, // Fewer ticks for cleaner appearance
                        maxRotation: 0,
                        color: 'rgba(255, 255, 255, 0.5)', // Lighter text color
                        font: {
                            size: 10 // Smaller font size
                        }
                    }
                },
                y: {
                    display: true,
                    grid: {
                        color: 'rgba(255, 255, 255, 0.05)', // Very subtle grid lines
                        drawBorder: false,
                        z: -1 // Draw grid behind the data
                    },
                    title: {
                        display: false // Hide title for cleaner look
                    },
                    ticks: {
                        color: 'rgba(255, 255, 255, 0.5)', // Lighter text color
                        padding: 10,
                        font: {
                            size: 10 // Smaller font size
                        },
                        callback: function(value) {
                            return value + ' W'; // Add watts unit to y-axis values
                        }
                    },
                    beginAtZero: true
                }
            },
            plugins: {
                legend: {
                    display: false // Hide legend for cleaner look
                },
                tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.7)',
                    titleColor: '#E68A00', // Unraid orange for title
                    bodyColor: '#FFFFFF',
                    borderColor: '#E68A00',
                    borderWidth: 1,
                    padding: 10,
                    displayColors: false,
                    callbacks: {
                        title: function(tooltipItems) {
                            return tooltipItems[0].label; // Time
                        },
                        label: function(context) {
                            return 'Power: ' + context.parsed.y.toFixed(2) + ' W';
                        }
                    }
                }
            }
        }
    });
}

// Function to update the power graph with new data
function updatePowerGraph(power) {
    // Add current timestamp
    const now = new Date();
    const timeLabel = now.toLocaleTimeString();
    
    // Add new data point
    powerData.labels.push(timeLabel);
    powerData.datasets[0].data.push(power);
    
    // Limit the number of data points to keep performance good
    if (powerData.labels.length > MAX_DATA_POINTS) {
        powerData.labels.shift();
        powerData.datasets[0].data.shift();
    }
    
    // Update the chart with smooth animation for flowing effect
    if (powerChart) {
        // Configure animation for smooth transitions
        powerChart.options.animation = {
            duration: 750,  // Fixed animation duration for consistency
            easing: 'cubic-bezier(0.4, 0, 0.2, 1)',  // Smooth easing function
            from: (ctx) => {
                if (ctx.type === 'data') {
                    // Interpolate from the previous value for smoother transitions
                    const datasetMeta = powerChart.getDatasetMeta(ctx.datasetIndex);
                    const previous = datasetMeta.data[ctx.index - 1];
                    return previous ? previous.y : ctx.to;
                }
                return ctx.to;
            }
        };
        
        // Update with animation
        powerChart.update('active');
    }
}

// Update power data when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Initialize the power graph
    initializePowerGraph();
    
    // Initial setup of refresh interval
    setupRefreshInterval();
    
    // Update interval when refresh rate changes directly
    document.getElementById('UIREFRESH').addEventListener('input', function() {
        // Only update if the field is not empty
        if (this.value.trim() !== '') {
            setupRefreshInterval();
        }
    });
});

// Update power data when IP changes
document.getElementById('DEVICE_IP').addEventListener('change', updateDeviceStatus);
</script>
